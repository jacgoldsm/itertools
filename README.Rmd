---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# itertools

<!-- badges: start -->
<!-- badges: end -->

The {itertools} package is aimed at making it easier to generate irregular
sequences that are difficult to generate with existing tools. The heart
of {itertools} is the `S3` class `Iterator`. An `Iterator` allows the
user to write an arbitrary R expression that returns the next
element of a sequence of R objects. It then saves the state of the `Iterator`, meaning the next time `yield_next` is called, the subsequent element of the sequence will be returned.

The package also provides a simple, tidy API for set building, allowing the user to generate a set consisting of the elements of a vector that meet specific criteria. This can either return a vector consisting of all the chosen elements or it can return an `Iterator` that lazily generates the chosen elements.

Finally, {itertools} also provides a new data structure stores a `data.frame` as an object with reference semantics and `O(1)` access to columns. This is useful when iterating over `data.frame`s with many columns, because the object is modified in place, rather than making a shallow copy on every iteration.

## Installation

You can install the released version of itertools from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("itertools")
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("jacgoldsm/itertools")
```
## Example
### Collatz

A Collatz sequence is a particular sequence of natural numbers that mathematicians think always reaches $1$ at some point, no matter the starting point. We can't prove that one way or the other, but we can create an `Iterator` that lazily generates a Collatz sequence until it reaches $1$:

```{r example}
library(itertools)
library(magrittr)
expr <- "if (n %% 2 == 0) n <- n / 2 else n <- n*3 + 1"
  
# Collatz generator starting at 50
collatz <- Iterator(result = expr,
                    initial = c(n = 50),
                    yield = n)

i <- 0
while (i != 1L) {
  i <- yield_next(collatz)
  cat(paste0(i, "\n"))
}
```
### Primes
How about generating all the prime numbers between $1$ and $100$? We can easily do that with the set-builder API:
```{r}
cat(2:100 %>% that_for_all(range(2, .x)) %>% we_have(~.x %% .y != 0))
```
But how about if we want to generate the first $100$ prime numbers? We don't know the range of values this should fall in (well, mathematicians do), so we can use laziness to our advantage:
```{r}
primes <- 2:10000 %>%
            that_for_all(range(2, .x)) %>% 
            we_have(~.x %% .y != 0, "Iterator")

sequence <- c()
while (length(sequence) <= 100) {
  sequence <- c(sequence, yield_next(primes))
}

cat(sequence)
```
### hash_df
When dealing with text data, it is common to run models on a very wide data set, with thousands of variables representing each token. Doing transformations on a wide data set can be very expensive, as every time a column is transformed, a shallow copy is made of the `data.frame`.

Here is an example of a wide data set representing the reviews of a great variety of wines. Each column represents a token, and the values represent the raw count of the number of times the word appears in a given review.
```{r echo=FALSE}
load("wide.rds")
wide_descriptions[1:5, 1:5]
```

