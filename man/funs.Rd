% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/that_for_{all,any}.R
\name{sets}
\alias{sets}
\alias{that_for_all}
\alias{that_for_any}
\alias{we_have}
\title{R Set Comprehension}
\usage{
that_for_all(set1, set2)

that_for_any(set1, set2)

we_have(that_for, formula, eval = "eager")
}
\arguments{
\item{set1}{A superset}

\item{set2}{A subset of set1}

\item{formula}{A logical formula to test elements from set1 against those from set2}

\item{eval}{Should evaluation be eager (return a vector) or lazy (return an Iterator)?}
}
\value{
For that_for_all and that_for_any, an object of S3 class that_for_all or that_for_any.
For we_have, a vector of the same type as set1 if eval == 'eager' and an Iterator object if eval == 'lazy'.
}
\description{
Set comprehension with the Magrittr Pipe.
Always use the syntax: set1 \%>\% that_for_all(set2) \%>\% we_have(formula).
Note: if set2 is an numeric vector, you probably want a value obtained from
itertools::range(start, end) rather than start:end or seq(start,end), as when
start is greater than end you want an empty vector rather than counting backwards.
Note that itertools::range views end as a supremum, not a maximum, thus range(a,b)
is equivalent to the set \code{[}a,b) when a < b or \code{{}} when b >= a.
}
\examples{
2:100 \%>\% that_for_all(range(2,x)) \%>\% we_have(~.x \%\% .y != 0) #is equivalent to
reticulate::py_eval('{i for i in range(2,101) if all(i \% y for y in range(2,i-1))}')
#c.f.
primes <- 2:100 \%>\% that_for_all(range(2,x)) \%>\% we_have(~.x \%\% .y != 0, "lazy")
yield_next(primes)
c("I", "Don't", "wan't", "chicken") \%>\% that_for_all('\'') \%>\% we_have(~stringr::str_detect(.x, .y))
#Twin primes 1 through 100
primes <- 2:100 \%>\% that_for_all(range(2,x)) \%>\% we_have(~.x \%\% .y != 0)
primes \%>\% that_for_any(primes) \%>\% we_have(~abs(.x - .y) == 2)
#Prime numbers 1 through 100 that are two away from a square number
(2:100 \%>\% that_for_all(range(2,x)) \%>\% we_have(~.x \%\% .y != 0)) \%>\%
    that_for_any(range(2,x)) \%>\% we_have(~sqrt(.x + 2) == .y | sqrt(.x - 2) == .y)

}
